#!/usr/bin/env node

// src/generate-icon-fonts/data.ts
var gifOptions = [
  {
    name: "ignoreGlobs",
    description: "Path icon glob to exclude from the fonts",
    array: true
  },
  {
    name: "variants",
    description: 'Font variants e.g. solid, inverted, etc. We always add a "default" variant for icons.',
    array: true,
    defaultValue: []
  },
  {
    name: "cleanIgnoreVariants",
    description: "Ignore variants which should not be cleaned automatically",
    array: true,
    defaultValue: []
  },
  {
    name: "skipClean",
    description: "Skip cleaning process",
    defaultValue: false,
    short: "sc"
  },
  {
    name: "withSizes",
    description: "Splits the font into different sizes"
  },
  {
    name: "src",
    description: "Src folder with all svgs",
    required: true
  },
  {
    name: "prefix",
    description: "Prefix of icons to delete for icons"
  },
  {
    name: "fontName",
    description: "The name of your font",
    required: true
  },
  {
    name: "dryRun",
    short: "dry",
    description: "prints the output of the command"
  },
  {
    name: "debug",
    description: "Extra logging",
    defaultValue: false
  },
  {
    name: "overwriteSources",
    short: "ows",
    description: "Overwrite all svgs inside src directory",
    defaultValue: false
  }
  // TODO: This is buggy we should fix it by making a PR to https://github.com/jaywcjlove/svgtofont
  /*  {
    name: "outSVGReact",
    description: "Creates react svg components",
    short: "react",
    defaultValue: false,
  },*/
];

// src/program.ts
import { program } from "commander";
var startProgram = (name, description, options, action2) => {
  program.name(name).description(description);
  for (const option of options) {
    const short = option.short && (option.short?.startsWith("-") ? option.short : `-${option.short}`) || `-${option.name.charAt(0)}`;
    const long = option.long || `--${option.name} ${option.array ? "[" : "<"}${option.name}${option.array ? "s...]" : ">"}`;
    if (option.required) {
      program.requiredOption(
        `${short}, ${long}`,
        option.description || "",
        option.defaultValue
      );
    } else {
      program.option(
        `${short}, ${long}`,
        option.description || "",
        option.defaultValue
      );
    }
  }
  program.action(action2);
  program.parse();
};
var program_default = startProgram;

// src/generate-icon-fonts/index.ts
import FSE2 from "fs-extra";

// src/generate-icon-fonts/svg-to-font.ts
import { fileURLToPath } from "node:url";
import path from "node:path";
import svgtofont from "svgtofont";
import { log } from "console";
var svgToFont = async (temporaryDirectory, dist, options) => {
  const { fontName, debug, svgoOptions, outSVGReact, svgicons2svgfont } = options;
  const fileName = fileURLToPath(import.meta.url);
  let lastSlashIndex = fileName.lastIndexOf("\\");
  if (lastSlashIndex === -1) {
    lastSlashIndex = fileName.lastIndexOf("/");
  }
  let generateIconFontsDir = fileName.slice(0, Math.max(0, lastSlashIndex));
  if (generateIconFontsDir.endsWith("generate-icon-fonts")) {
    generateIconFontsDir = generateIconFontsDir.replace(
      "generate-icon-fonts",
      ""
    );
  }
  try {
    return svgtofont({
      src: temporaryDirectory,
      dist,
      fontName,
      log: debug,
      logger: (message) => log(message),
      css: true,
      outSVGReact,
      outSVGPath: true,
      useNameAsUnicode: true,
      generateInfoData: true,
      svgoOptions,
      svgicons2svgfont: {
        fontHeight: 1e3,
        normalize: true,
        centerHorizontally: true,
        ...svgicons2svgfont
      },
      website: {
        index: "font-class",
        template: path.resolve(generateIconFontsDir, "templates/index.njk"),
        links: [{ title: "", url: "" }]
      },
      styleTemplates: path.resolve(generateIconFontsDir, "styles")
    });
  } catch (error2) {
    console.error(error2);
  }
  return true;
};
var svg_to_font_default = svgToFont;

// src/clean-icons/index.ts
import { globSync } from "glob";
import SVGFixer from "oslllo-svg-fixer";
import { error } from "console";
var cleanIcons = async (src, ignoreGlobs, traceResolution, debug) => {
  const paths = `${src}/**/*.svg`;
  const options = {};
  if (ignoreGlobs) {
    options.ignore = ignoreGlobs;
  }
  const globPaths = globSync(paths, options).map((path2) => path2.replace(/\\/g, "/")).map((path2) => path2.slice(0, Math.max(0, path2.lastIndexOf("/")))).filter((v, i, self) => i === self.indexOf(v));
  const promises = globPaths.map(async (path2) => {
    try {
      return await SVGFixer(path2, path2, {
        showProgressBar: debug,
        traceResolution: Number(traceResolution || "600")
      }).fix();
    } catch (catchError) {
      error(path2, catchError);
      return catchError;
    }
  });
  await Promise.all(promises);
};
var clean_icons_default = cleanIcons;

// src/generate-icon-fonts/gather-icons.ts
import FSE from "fs-extra";
import { globSync as globSync2 } from "glob";
import { log as log2 } from "console";
var generalPrefix = "";
var availableSizes = [12, 14, 16, 20, 24, 28, 32, 48, 64];
var componentSizes = [32, 24, 20];
var allTemporaryDir = "all";
var initTemporaryIconFiles = (globPaths, temporaryDirectory, prefix) => {
  const foundIconFiles = [];
  for (const svgPath of globPaths) {
    const paths = svgPath.split("/");
    let filename = paths.at(-1) || "";
    let iconName;
    if (prefix) {
      filename = filename.replace(prefix, "");
    }
    iconName = filename.replace(".svg", "");
    for (const size of availableSizes) {
      iconName = iconName.replace(`_${size}`, "");
    }
    FSE.copyFileSync(
      svgPath,
      `${temporaryDirectory}/${allTemporaryDir}/${generalPrefix}${filename}`
    );
    if (iconName && !foundIconFiles.includes(iconName)) {
      foundIconFiles.push(iconName);
    }
  }
  return foundIconFiles;
};
var getVariantFileName = (iconFileName, variant) => variant === "" ? iconFileName : `${iconFileName}_${variant}`;
var initDefaultFile = (temporaryDirectory, iconFileName, variant) => {
  const fileName = getVariantFileName(iconFileName, variant);
  const defaultFileExists = FSE.existsSync(
    `${temporaryDirectory}/${allTemporaryDir}/${generalPrefix}${fileName}.svg`
  );
  if (!defaultFileExists) {
    for (const size of componentSizes) {
      const sizeFileName = `${temporaryDirectory}/${allTemporaryDir}/${generalPrefix}${fileName}_${size}.svg`;
      const altSizeFileName = `${temporaryDirectory}/${allTemporaryDir}/${generalPrefix}${iconFileName}_${size}_${variant}.svg`;
      for (const name of [sizeFileName, altSizeFileName]) {
        if (FSE.existsSync(name)) {
          FSE.copyFileSync(
            name,
            `${temporaryDirectory}/${allTemporaryDir}/${generalPrefix}${fileName}.svg`
          );
          return;
        }
      }
    }
  }
};
var createFallbackComponentSize = (temporaryDirectory, iconFileName, variant, fileName, path2, size, alt) => {
  const nextBestSizeArray = size === 20 ? [24, 32] : size === 24 ? [20, 32] : [24, 20];
  for (const nextSize of nextBestSizeArray) {
    const nextSizeFilePath = alt ? `${temporaryDirectory}/${allTemporaryDir}/${generalPrefix}${iconFileName}_${nextSize}_${variant}.svg` : `${temporaryDirectory}/${allTemporaryDir}/${generalPrefix}${fileName}_${nextSize}.svg`;
    if (FSE.existsSync(nextSizeFilePath)) {
      FSE.copyFileSync(nextSizeFilePath, path2);
      return true;
    }
  }
  return false;
};
var initComponentSizes = (temporaryDirectory, iconFileName, variant) => {
  const fileName = getVariantFileName(iconFileName, variant);
  for (const size of componentSizes) {
    const requiredFilePath = `${temporaryDirectory}/${allTemporaryDir}/${generalPrefix}${fileName}_${size}.svg`;
    const altRequiredFilePath = `${temporaryDirectory}/${allTemporaryDir}/${generalPrefix}${iconFileName}_${size}_${variant}.svg`;
    if (!FSE.existsSync(requiredFilePath)) {
      const created = createFallbackComponentSize(
        temporaryDirectory,
        iconFileName,
        variant,
        fileName,
        requiredFilePath,
        size,
        false
      );
      if (!created) {
        createFallbackComponentSize(
          temporaryDirectory,
          iconFileName,
          variant,
          fileName,
          altRequiredFilePath,
          size,
          true
        );
      }
    }
  }
};
var gatherIcons = (temporaryDirectory, values) => {
  const { src, ignoreGlobs, prefix, dryRun, variants, withSizes, debug } = values;
  const paths = `${src}/**/*.svg`;
  const splitSizesArray = withSizes ? ["", ...availableSizes] : [""];
  const splitVariantsArray = variants.length > 0 ? ["", ...variants] : [""];
  const globPaths = globSync2(paths, { ignore: ignoreGlobs }).map(
    (path2) => path2.replace(/\\/g, "/")
  );
  if (dryRun) {
    log2("files:", globPaths);
    return globPaths;
  }
  if (!FSE.existsSync(temporaryDirectory)) {
    FSE.mkdirSync(temporaryDirectory, { recursive: true });
  }
  if (!FSE.existsSync(`${temporaryDirectory}/${allTemporaryDir}`)) {
    FSE.mkdirSync(`${temporaryDirectory}/${allTemporaryDir}`, {
      recursive: true
    });
  }
  const foundIconFiles = initTemporaryIconFiles(
    globPaths,
    temporaryDirectory,
    prefix
  );
  if (debug) {
    log2(`Found ${foundIconFiles.length} icons`);
  }
  for (const variant of splitVariantsArray) {
    for (const iconFileName of foundIconFiles.filter(
      (fileName) => !variants.some((va) => fileName.includes(`_${va}`))
    )) {
      const fileName = getVariantFileName(iconFileName, variant);
      initDefaultFile(temporaryDirectory, iconFileName, variant);
      initComponentSizes(temporaryDirectory, iconFileName, variant);
      for (const size of splitSizesArray) {
        const sizeFileEnding = `${size === "" ? "" : `_${size}`}`;
        const directory = `${variant === "" ? "default" : variant}${sizeFileEnding}`;
        const defaultFilePath = `${temporaryDirectory}/${allTemporaryDir}/${generalPrefix}${fileName}.svg`;
        const sizeFilePath = `${temporaryDirectory}/${allTemporaryDir}/${generalPrefix}${fileName}${sizeFileEnding}.svg`;
        const fallbackFilePath = `${temporaryDirectory}/${allTemporaryDir}/${generalPrefix}${iconFileName}.svg`;
        const fallbackSizeFilePath = `${temporaryDirectory}/${allTemporaryDir}/${generalPrefix}${iconFileName}${sizeFileEnding}.svg`;
        const placeholderFilePath = `${temporaryDirectory}/${allTemporaryDir}/${generalPrefix}x_placeholder.svg`;
        const placeholderSizeFilePath = `${temporaryDirectory}/${allTemporaryDir}/${generalPrefix}x_placeholder${sizeFileEnding}.svg`;
        if (!FSE.existsSync(`${temporaryDirectory}/${directory}`)) {
          FSE.mkdirSync(`${temporaryDirectory}/${directory}`, {
            recursive: true
          });
        }
        if (FSE.existsSync(sizeFilePath)) {
          FSE.copyFileSync(
            sizeFilePath,
            `${temporaryDirectory}/${directory}/${generalPrefix}${iconFileName}.svg`
          );
        } else if (FSE.existsSync(defaultFilePath)) {
          FSE.copyFileSync(
            defaultFilePath,
            `${temporaryDirectory}/${directory}/${generalPrefix}${iconFileName}.svg`
          );
        } else if (FSE.existsSync(placeholderSizeFilePath)) {
          FSE.copyFileSync(
            placeholderSizeFilePath,
            `${temporaryDirectory}/${directory}/${generalPrefix}${iconFileName}.svg`
          );
        } else if (FSE.existsSync(placeholderFilePath)) {
          FSE.copyFileSync(
            placeholderFilePath,
            `${temporaryDirectory}/${directory}/${generalPrefix}${iconFileName}.svg`
          );
        } else if (FSE.existsSync(fallbackSizeFilePath)) {
          FSE.copyFileSync(
            fallbackSizeFilePath,
            `${temporaryDirectory}/${directory}/${generalPrefix}${iconFileName}.svg`
          );
        } else {
          FSE.copyFileSync(
            fallbackFilePath,
            `${temporaryDirectory}/${directory}/${generalPrefix}${iconFileName}.svg`
          );
        }
      }
    }
  }
  return globPaths;
};
var gather_icons_default = gatherIcons;

// src/generate-icon-fonts/index.ts
import { log as log3 } from "console";
var debugLog = (debug, message) => {
  if (debug) {
    log3(message);
  }
};
var generateIconFonts = async (values) => {
  const {
    src,
    dryRun,
    cleanIgnoreVariants,
    debug = false,
    overwriteSources = false,
    traceResolution = "600",
    skipClean = false
  } = values;
  const dist = `${src}/fonts`;
  const temporaryDirectory = `${src}/tmp`;
  const ignoreVariants = [...cleanIgnoreVariants].map(
    (igVar) => `**/${igVar}*/**`
  );
  if (dryRun) {
    log3("values:", values);
    return gather_icons_default(temporaryDirectory, values);
  } else {
    if (FSE2.existsSync(temporaryDirectory)) {
      FSE2.removeSync(temporaryDirectory);
    }
    if (FSE2.existsSync(dist)) {
      FSE2.removeSync(dist);
    }
    debugLog(debug, "---Start gathering icon---");
    const iconPaths = gather_icons_default(temporaryDirectory, values);
    if (skipClean) {
      debugLog(debug, "---Skip cleaning icon---");
    } else {
      debugLog(debug, "---Start cleaning icon---");
      await clean_icons_default(
        `${temporaryDirectory}/*`,
        ignoreVariants,
        traceResolution,
        debug
      );
    }
    debugLog(debug, "---Start svg to font ---");
    const allTemporaryDirectories = FSE2.readdirSync(temporaryDirectory);
    for (const directory of allTemporaryDirectories) {
      const subDist = `${dist}/${directory}`;
      const subTemporaryDir = `${temporaryDirectory}/${directory}`;
      debugLog(debug, `svgToFont for ${subTemporaryDir}`);
      await svg_to_font_default(subTemporaryDir, subDist, values);
      FSE2.removeSync(`${subDist}/symbol.html`);
      FSE2.removeSync(`${subDist}/unicode.html`);
    }
    if (overwriteSources && iconPaths) {
      const tempAllDir = `${temporaryDirectory}/all`;
      iconPaths.forEach((svgPath) => {
        const paths = svgPath.split("/");
        const filename = paths.at(-1) || "";
        const tmpFile = `${tempAllDir}/${filename}`;
        if (FSE2.existsSync(`${tempAllDir}/${filename}`)) {
          FSE2.copySync(tmpFile, svgPath, {
            overwrite: true
          });
        }
      });
    }
    if (!debug) {
      FSE2.removeSync(temporaryDirectory);
    }
  }
  return true;
};
var generate_icon_fonts_default = generateIconFonts;

// src/generate-icon-fonts/cli.ts
var action = async (_, options) => {
  const values = options._optionValues;
  generate_icon_fonts_default(values);
};
program_default(
  "@db-ui/gif - generate icon fonts",
  "CLI to generate icon fonts for DB UX Design System",
  gifOptions,
  action
);
